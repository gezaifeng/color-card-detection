import numpy as np
import cv2
import rawpy  # 用于处理 CR2
from PIL import Image
import matplotlib
matplotlib.use('TkAgg')  # 让 plt.show() 正常显示
import matplotlib.pyplot as plt
import os

# ✅ 输入和输出文件夹
input_dir = "D:\Desktop\Converted_JPG\yellow"
output_dir = "D:\\Desktop\\extracted"  # 你的输出目录
os.makedirs(output_dir, exist_ok=True)  # 确保输出文件夹存在

# ✅ 颜色矩阵网格大小
GRID_ROWS, GRID_COLS = 4, 6
TARGET_WIDTH, TARGET_HEIGHT = 400, 500
LONG_EDGE_CROP_RATIO = 0.05  # 长边缩进 5%
SHORT_EDGE_CROP_RATIO = 0.03  # 短边缩进 3%

def find_images(directory):
    """ ✅ 递归搜索文件夹中的所有图片文件，包括 CR2 """
    image_paths = []
    for root, _, files in os.walk(directory):  # 递归遍历目录
        for file in files:
            if file.lower().endswith(('jpg', 'png', 'jpeg', 'cr2')):  # ✅ 添加 CR2 支持
                image_paths.append(os.path.join(root, file))
    return image_paths

def get_output_path(image_path, file_ext):
    """ ✅ 根据原始文件夹层级生成输出路径 """
    relative_path = os.path.relpath(image_path, input_dir)  # 获取相对路径
    relative_dir = os.path.dirname(relative_path)  # 获取相对文件夹
    output_folder = os.path.join(output_dir, relative_dir)  # 生成输出文件夹
    os.makedirs(output_folder, exist_ok=True)  # 确保文件夹存在
    filename = os.path.splitext(os.path.basename(image_path))[0]  # 获取文件名（无扩展名）
    return os.path.join(output_folder, f"rgb_{filename}.{file_ext}")

def load_image(image_path):
    """ ✅ 兼容 JPG/PNG 和 CR2 格式 """
    if image_path.lower().endswith('.cr2'):
        with rawpy.imread(image_path) as raw:
            rgb_image = raw.postprocess(output_bps=8)  # 转换为 8-bit RGB
            return Image.fromarray(rgb_image)  # 转换为 PIL 格式
    else:
        return Image.open(image_path)  # 直接打开 JPG/PNG

def visualize_results(image_path, edges, cropped_image, npy_file):
    """ ✅ 可视化：原图 + 边缘检测 + 裁剪范围 + 读取 .npy 并可视化颜色矩阵 """
    colors = np.load(npy_file)  # 读取 .npy 文件
    colors = np.clip(colors / 255.0, 0, 1)  # 归一化到 0-1

    # ✅ 确保正确读取原始图片（JPG/PNG/CR2）
    original_image = np.array(load_image(image_path))

    fig, ax = plt.subplots(1, 4, figsize=(18, 5))

    # ✅ 第一张图：原始图像
    ax[0].imshow(original_image)
    ax[0].set_title("Original Image")
    ax[0].axis("off")

    # ✅ 第二张图：边缘检测
    ax[1].imshow(edges, cmap='gray')
    ax[1].set_title("Edge Detection")
    ax[1].axis("off")

    # ✅ 第三张图：裁剪后的图片（包含分割线）
    ax[2].imshow(cv2.cvtColor(cropped_image, cv2.COLOR_BGR2RGB))  # BGR → RGB
    ax[2].set_title("Cropped Image with Grid")
    ax[2].axis("off")

    # ✅ 第四张图：从 `.npy` 读取并展示 4×6 颜色矩阵
    ax[3].set_xticks([])
    ax[3].set_yticks([])
    for row in range(GRID_ROWS):
        for col in range(GRID_COLS):
            rect = plt.Rectangle((col, GRID_ROWS - row - 1), 1, 1, facecolor=colors[row, col])
            ax[3].add_patch(rect)
    ax[3].set_xlim(0, GRID_COLS)
    ax[3].set_ylim(0, GRID_ROWS)
    ax[3].set_title("Extracted RGB Matrix")

    plt.suptitle(os.path.basename(image_path))
    plt.tight_layout()
    plt.show()

def process_image(image_path):
    """ ✅ 处理单张图片，返回 RGB 颜色矩阵 """
    # ✅ 读取图像（支持 CR2 / JPG / PNG）
    im = load_image(image_path)
    im_gray = np.array(im.convert('L'))  # 转换为灰度图的 NumPy 数组
    im_array = np.array(im)  # 原始 RGB 图像

    # ✅ 计算 Sobel 梯度
    grad_x = cv2.Sobel(im_gray, cv2.CV_64F, 1, 0, ksize=3)
    grad_y = cv2.Sobel(im_gray, cv2.CV_64F, 0, 1, ksize=3)
    grad_magnitude = np.sqrt(grad_x**2 + grad_y**2)
    grad_magnitude = np.uint8(255 * grad_magnitude / grad_magnitude.max())

    # ✅ 二值化处理
    _, binary = cv2.threshold(grad_magnitude, 50, 255, cv2.THRESH_BINARY)

    # ✅ 连通区域分析
    num_labels, labels, stats, _ = cv2.connectedComponentsWithStats(binary, connectivity=8)
    largest_label = 1 + np.argmax(stats[1:, cv2.CC_STAT_AREA])
    largest_region = (labels == largest_label).astype(np.uint8) * 255

    # ✅ 查找轮廓
    contours, _ = cv2.findContours(largest_region, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    rect = cv2.minAreaRect(contours[0])
    box = cv2.boxPoints(rect).astype(int)

    # ✅ 透视变换
    src_pts = np.float32(box)
    dst_pts = np.float32([[0, 0], [TARGET_WIDTH, 0], [TARGET_WIDTH, TARGET_HEIGHT], [0, TARGET_HEIGHT]])
    M = cv2.getPerspectiveTransform(src_pts, dst_pts)
    warped_image = cv2.warpPerspective(im_array, M, (TARGET_WIDTH, TARGET_HEIGHT))

    # ✅ 裁剪
    h, w = warped_image.shape[:2]
    crop_x, crop_y = int(w * LONG_EDGE_CROP_RATIO), int(h * SHORT_EDGE_CROP_RATIO)
    cropped_final = warped_image[crop_y:h-crop_y, crop_x:w-crop_x]

    # ✅ 旋转裁剪后的图像（逆时针 90°）
    cropped_final = cv2.rotate(cropped_final, cv2.ROTATE_90_COUNTERCLOCKWISE)

    # ✅ 提取颜色矩阵
    rgb_array = extract_rgb_from_grid(cropped_final)  # 形状 (4,6,3)

    # ✅ 保存数据
    npy_path = get_output_path(image_path, "npy")
    np.save(npy_path, rgb_array.astype(np.float32))

    print(f"✅ 颜色数据已保存至: {npy_path}")

    # ✅ 可视化
    visualize_results(image_path, grad_magnitude, cropped_final, npy_path)
def extract_rgb_from_grid(image):
    """ 提取 4×6 颜色矩阵，中心 10% 面积的 RGB 均值，并直接在 `image` 上绘制分割线和选取框 """
    h, w = image.shape[:2]
    cell_h, cell_w = h // GRID_ROWS, w // GRID_COLS
    rgb_values = np.zeros((GRID_ROWS, GRID_COLS, 3), dtype=np.float32)

    for row in range(GRID_ROWS):
        for col in range(GRID_COLS):
            x1, y1 = col * cell_w, row * cell_h
            x2, y2 = x1 + cell_w, y1 + cell_h

            # **绘制红色网格**
            cv2.rectangle(image, (x1, y1), (x2, y2), (0, 0, 255), 2)

            # **计算中心选取区域**
            center_x1 = int(x1 + 0.25 * cell_w)
            center_x2 = int(x1 + 0.75 * cell_w)
            center_y1 = int(y1 + 0.25 * cell_h)
            center_y2 = int(y1 + 0.75 * cell_h)

            center_patch = image[center_y1:center_y2, center_x1:center_x2]

            # **绘制蓝色方框**
            cv2.rectangle(image, (center_x1, center_y1), (center_x2, center_y2), (255, 0, 0), 2)

            # **计算 RGB 均值**
            rgb_values[row, col] = np.mean(center_patch, axis=(0, 1))

    return rgb_values  # **返回 (4,6,3) 形状的 NumPy 数组**
def batch_process_images():
    """  递归处理所有子文件夹中的图片 """
    images = find_images(input_dir)
    for img_path in images:
        process_image(img_path)

#  运行批量处理
batch_process_images()
